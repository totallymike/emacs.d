#+TITLE: Michael Westbom's Emacs configuration
#+OPTIONS: toc:4 h:4

* Configuration
<<babel-init>>

** Package management
*** Sources
    Let's begin by setting up the package system.  First we'll disable it,
    then make sure melpa, the de-facto package repo, is enabled.

    #+begin_src emacs-lisp
      (setq package-enable-at-startup nil)
      (unless (assoc-default "melpa" package-archives)
        (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
        (package-refresh-contents))

      (package-initialize)
    #+end_src
*** use-package
    Now we'll enable John Wiegley's phenomenal [[https://github.com/jwiegley/use-package][use-package]] library:

    #+begin_src emacs-lisp
      (unless (package-installed-p 'use-package)
        (package-refresh-contents)
        (package-install 'use-package))

      (require 'use-package)
    #+end_src

** General configuration
*** Customize
    Going to move away from customize eventually, but
    until then, let's use the customizations I've got:

    #+begin_src emacs-lisp
      (setq custom-file
            (expand-file-name "customizations.el" user-emacs-directory))
      (load custom-file)
    #+end_src
*** Apple keyboards
    Swap super and meta for macs.  This retains option being alt as in the rest of the OS.
    #+BEGIN_SRC emacs-lisp
      (setq mac-command-modifier 'super
            mac-option-modifier 'meta)
    #+END_SRC
*** No blinking.
    Seriously.
    #+begin_src emacs-lisp
    (blink-cursor-mode 0)
    #+end_src
*** Help and discoverability.

Let's enable guide-key.  This tells you what possible bindings
are available based on what you've already pressed.

#+Begin_src emacs-lisp
  (use-package guide-key-tip
    :ensure t
    :init
    (progn
      (setq guide-key/guide-key-sequence `("C-x"
                                           "C-c"
                                           "C-h")
            guide-key/recursive-key-sequence-flag t
            guide-key/text-scale-amount 0
            guide-key-tip/enabled nil)
      (guide-key-mode 1)))
#+end_src

*** Whitespace
**** Clean up trailing whitespace stuff in terminals
     #+BEGIN_SRC emacs-lisp
       (add-hook 'term-mode-hook
                 (lambda ()
                   (setq show-trailing-whitespace nil)))

       (add-hook 'eshell-mode-hook
                 (lambda ()
                   (setq show-trailing-whitespace nil)))
     #+END_SRC
*** Line numbers
**** Modeline
    #+begin_src emacs-lisp
    ;; Add line/column numbers to modeline
    (line-number-mode t)
    (column-number-mode t)
    #+end_src

**** Selectively enable linum-mode
     =linum-mode= enables gutter line numbers. Disable it for specific modes.

     From [[http://emacswiki.org/emacs/linum-off.el][emacswiki]]
     #+begin_src emacs-lisp
       (require 'linum)

       (defcustom linum-disabled-modes-list '(eshell-mode
                                              wl-summary-mode
                                              compilation-mode
                                              org-mode
                                              text-mode
                                              dired-mode
                                              doc-view-mode
                                              image-mode)
         "* List of modes disabled when global linum mode is on"
         :type '(repeat (sexp :tag "Major mode"))
         :tag " Major modes where linum is disabled"
         :group 'linum)

       (defcustom linum-disable-starred-buffers 't
         "* Disable buffers that have stars in them like *Gnu Emacs*"
         :type 'boolean
         :group 'linum)

       (defun linum-on ()
         "* When linum is running globally, disable line numbers in modes
       defined in `linum-disabled-modes-list'. Changed by linum-off.
       Also turns off numbering in starred modes like *scratch*."
         (unless (or (minibufferp)
                     (member major-mode linum-disabled-modes-list)
                     (string-match "*" (buffer-name))
                     (> (buffer-size) 3000000)) ;; Don't number huge files
           (linum-mode 1)))
       (provide 'linum-off)
     #+end_src

*** Change "yes or no" to "y or n"
    y is just fine, thank you.

    #+begin_src emacs-lisp
    (fset 'yes-or-no-p 'y-or-n-p)
    #+end_src
*** Color scheme

    Zenburn. Set it.  If it's not there, download it.

#+begin_src emacs-lisp
  (defun mcw/load-theme ()
    (if (package-installed-p 'zenburn-theme)
        (load-theme 'zenburn)
      (progn
        (package-install 'zenburn-theme)
        (mcw/load-theme))))

  (mcw/load-theme)
#+end_src

*** Helm
    Helm is, in my opinion, the best minibuffer completion thing.
    Let's stick it just about everywhere.

    Also replace the standard =M-x= with =helm-M-x=

    #+begin_src emacs-lisp
    (use-package helm
    :ensure t
    :init
    (progn
      (require 'helm-config)
      (global-set-key (kbd "M-x") 'helm-M-x)
      (global-set-key (kbd "M-y") 'helm-show-kill-ring)
      (helm-mode)))
    #+end_src

**** Disable ido-mode
    Don't need ido-mode.  Disable it.

    #+begin_src emacs-lisp
    (ido-mode -1)
    #+end_src

**** helm-descbinds
    helm-descbinds is pretty great.  =C-h b= brings up a helm-powered
    list of available bindings in the current mode.
    #+begin_src emacs-lisp
    (use-package helm-descbinds
    :ensure helm-descbinds
    :config
      (helm-descbinds-mode))
    #+end_src
*** Backups

Turn on a whole mess of backup/save stuff. I'll probably cut
this out eventually.

#+begin_src emacs-lisp
  (setq
   backup-by-copying t
   backup-directory-alist '(("." . "~/.emacs.d/saves"))
   delete-old-versions nil
   version-control t)

  (let
      ((autosave-dir (expand-file-name "autosave" user-emacs-directory)))
    (unless (file-exists-p autosave-dir)
      (make-directory autosave-dir))
    (setq auto-save-list-file-prefix (concat autosave-dir "/")
          auto-save-file-name-transforms `((".*" ,autosave-dir t))))

  (setq gc-cons-threshold 200000000)
#+end_src

*** Modeline
    The default modeline can get unwieldy, and go wider than the frame.

    Add Bruce Connor's [[https://github.com/Bruce-Connor/smart-mode-line][smart-mode-line]] to make for a prettier and more
    manageable modeline

    #+begin_src emacs-lisp
      (use-package smart-mode-line
        :ensure smart-mode-line
        :pre-init
        :init
        (progn
          (use-package smart-mode-line-powerline-theme
            :ensure smart-mode-line-powerline-theme))
        :config
        (progn
          (sml/setup)))
    #+end_src

*** Undo Tree
    Undo tree is fabulous
    #+begin_src emacs-lisp
      (use-package undo-tree
        :ensure undo-tree
        :diminish undo-tree-mode
        :init
        (progn
          (global-undo-tree-mode)))
    #+end_src
*** Window management
**** Window splitting
     Stole these from
     [[http://pages.sachachua.com/.emacs.d/Sacha.html#unnumbered-28][Sacha Chua]]
    #+begin_src emacs-lisp
      (defun vsplit-last-buffer ()
        (interactive)
        (split-window-vertically)
        (other-window 1 nil)
        (switch-to-next-buffer))

      (defun hsplit-last-buffer ()
        (interactive)
        (split-window-horizontally)
        (other-window 1 nil)
        (switch-to-next-buffer))

      (global-set-key (kbd "C-x 2") 'vsplit-last-buffer)
      (global-set-key (kbd "C-x 3") 'hsplit-last-buffer)
    #+end_src

**** Winner mode
     Winner mode adds an undo history to window configurations.
     #+begin_src emacs-lisp
       (use-package winner
         :ensure winner
         :init (winner-mode 1))
     #+end_src
** Navigation
*** The Silver Searcher
    Enable integration with Ag.  This must happen before [[Projectile]]
    #+BEGIN_SRC emacs-lisp
      (use-package helm-ag
        :ensure helm-ag)
    #+END_SRC
*** Windmove
     Windmove beats using =C-x o= to toggle through windows

     Let's switch the binding from =Super= to =Meta= though
     #+begin_src emacs-lisp
       (use-package windmove
          :init (progn
                  (windmove-default-keybindings 'meta)))
     #+end_src

*** Beginning of line
    Instead of =C-a= moving to column 0, go to first non-whitespace
    character.  THEN go to column 0.  And back again.
    #+BEGIN_SRC emacs-lisp
      (defun smarter-move-beginning-of-line (arg)
        "Move point back to indentation of beginning of line.

      Move point to the first non-whitespace character on this line.
      If point is already there, move to beginning of the line.
      Effectively toggle between the first non-whitespace character and
      the beginning of the line.

      If ARG is not nil or 1, move forward ARG - 1 lines first.
      If point reaches the beginning or end of the buffer, stop there."
        (interactive "^p")
        (setq arg (or arg 1))

        ;; Move lines first
        (when (/= arg 1)
          (let ((line-move-visual nil))
            (forward (1- arg))))

        (let ((orig-point (point)))
          (back-to-indentation)
          (when (= orig-point (point))
            (move-beginning-of-line 1))))

      ;; remap C-a to `smarter-move-beginning-of-line`
      (global-set-key [remap move-beginning-of-line]
                      'smarter-move-beginning-of-line)

    #+END_SRC
*** Pop to mark
    Haven't built this into muscle memory yet.
    #+begin_src emacs-lisp
      (bind-key "C-x p" 'pop-to-mark-command)
      (setq set-mark-command-repeat-pop t)
    #+end_src

*** Switch to previous buffer
    Switch to last buffer. Absolutely essential.
    #+begin_src emacs-lisp
      (defun mcw/switch-to-previous-buffer ()
        "Switch to previously open buffer.
      Repeated invocations toggle between the most recently open buffers."
        (interactive)
        (switch-to-buffer (other-buffer (current-buffer) 1)))

      (bind-key "C-c b" 'mcw/switch-to-previous-buffer)
    #+end_src
*** Projectile
    [[https://github.com/bbatsov/projectile][Projectile]] is a fantastic tool.
    #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :ensure projectile
        :diminish projectile-mode
        :init
        (progn
          (setq projectile-keymap-prefix (kbd "C-c p"))
          (projectile-global-mode)))
    #+END_SRC

    Also enable helm-projectile, which teaches projectile to use helm.
    #+BEGIN_SRC emacs-lisp
      (use-package helm-projectile
        :ensure helm-projectile
        :config
        (helm-projectile-on))
    #+END_SRC
** Org
*** Speed keys
    #+BEGIN_SRC emacs-lisp
      (setq org-use-speed-commands t)
    #+END_SRC

** Programming
*** Git
    Emacs has so many fantastic get-related tools.
**** Magit
     Magit is 90% of why I moved over to it in the first place.
     #+BEGIN_SRC emacs-lisp
       (use-package magit
         :commands magit-status
         :load-path "site-lisp/magit"
         :init (progn
                 (use-package dash
                   :ensure t)
                 (bind-key "C-x g" 'magit-status)))
     #+END_SRC

**** Gist
     Here's a handy tool for working with gists.  I don't use it very often, but I enjoy it when I do.
     #+BEGIN_SRC emacs-lisp
       (use-package gist
         :ensure gist
         :commands (gist-buffer gist-region gist-list))
     #+END_SRC

**** git-timemachine
     Lets you flip back and forth through a file's VC history
     #+BEGIN_SRC emacs-lisp
       (use-package git-timemachine
         :ensure git-timemachine)
     #+END_SRC
**** git-messenger
     Shows most recent commit message for line under mark
     #+BEGIN_SRC emacs-lisp
       (use-package git-messenger
         :ensure t
         :bind (("C-x v p" . git-messenger:popup-message)))
     #+END_SRC
*** Rainbows!
**** Rainbow identifiers
     Lots and lots of colors...
     #+BEGIN_SRC emacs-lisp
       (use-package rainbow-identifiers
         :ensure rainbow-identifiers
         :config (progn
                   (add-hook 'prog-mode-hook 'rainbow-identifiers-mode)))
     #+END_SRC

**** Rainbow Delimiters
     Individually color delimiters, to differentiate levels of nesting.
     #+BEGIN_SRC emacs-lisp
       (use-package rainbow-delimiters
         :ensure rainbow-delimiters
         :config (progn
                   (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)))
     #+END_SRC
*** Autocomplete
    Bring in company mode for autocomplete
    #+BEGIN_SRC emacs-lisp
      (use-package company
        :ensure company
        :diminish company-mode
        :config
        (add-hook 'prog-mode-hook 'company-mode))
    #+END_SRC
*** Flycheck
    Enables support for linting in a bunch of different languages.
    #+BEGIN_SRC emacs-lisp
      (use-package flycheck
        :ensure t
        :init
        (global-flycheck-mode))
    #+END_SRC
*** Smartparens
    Enable automatic matching of paired syntax tokens.  This is brilliant.
    #+BEGIN_SRC emacs-lisp
      (use-package smartparens
        :ensure smartparens
        :config
        (progn
          (require 'smartparens-config)
          (smartparens-global-mode 1)))
    #+END_SRC
*** Web mode
    Web mode is pretty great about handling mixed-mode files like
    HTML pages with javascript, or handlebars template pages.

    Enable it for handlebars files.
    #+BEGIN_SRC emacs-lisp
      (use-package web-mode
        :ensure t
        :mode ("\\.hbs\\'" . web-mode))
    #+END_SRC
*** Various language modes
**** Ruby
***** enh-ruby-mode
      Replace standard ruby mode with enh-ruby-mode.  I like its indentation engine better.
      #+BEGIN_SRC emacs-lisp
        (use-package enh-ruby-mode
          :ensure t
          :diminish enh-ruby-mode
          :commands enh-ruby-mode
          :init
          (progn
            (add-to-list 'auto-mode-alist '("\\.rb$" . enh-ruby-mode))
            (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))))
      #+END_SRC

***** rspec mode
      Run rspec from emacs.  I love this so much.
      #+BEGIN_SRC emacs-lisp
        (use-package rspec-mode
          :ensure rspec-mode
          :diminish rspec-mode
          :commands rspec-mode
          :init
          (progn
            (add-hook 'enh-ruby-mode-hook 'rspec-mode))
          :config
          (progn
            (setq rspec-command-options "--fail-fast --format documentation")
            (inf-ruby-switch-setup)))
      #+END_SRC

***** rbenv
      #+BEGIN_SRC emacs-lisp
        (use-package rbenv
          :ensure t
          :commands rbenv-use-global
          :init
          (progn
            (add-hook 'enh-ruby-mode-hook 'rbenv-use-global)))
      #+END_SRC
**** Markdown
    Enable markdown mode
    #+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
        :ensure t
        :mode ("\\.md\\'" . markdown-mode))
    #+END_SRC
**** Docker
    #+BEGIN_SRC emacs-lisp
      (use-package dockerfile-mode
        :ensure t
        :mode ("Dockerfile\\'" . dockerfile-mode))
    #+END_SRC
**** Javascript
     js2-mode seems to have the best indentation/linting support.
     #+BEGIN_SRC emacs-lisp
       (use-package js2-mode
         :commands js2-mode
         :ensure t
         :init
         (progn
           (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
           (add-to-list 'interpreter-mode-alist (cons "node" 'js2-mode))))
     #+END_SRC
**** Yaml
     #+BEGIN_SRC emacs-lisp
       (use-package yaml-mode
         :ensure yaml-mode
         :mode "\\.yml\\'")
     #+END_SRC
** Terminals and shells
**** Multi term
     multi-term adds some useful features, like running multiple
     terminal emulators, and a dedicated term buffer.
     #+BEGIN_SRC emacs-lisp
       (use-package multi-term
         :ensure multi-term
         :bind ("<f5>" . multi-term-dedicated-toggle))
     #+END_SRC

